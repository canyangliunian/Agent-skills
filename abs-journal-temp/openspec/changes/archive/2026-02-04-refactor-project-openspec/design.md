## Context

当前代码库的主要可执行能力集中在 Python 脚本（`scripts/ajg_fetch.py`），其目标是抓取 Chartered ABS Academic Journal Guide（AJG）并落地为结构化数据文件（JSONL/JSON/CSV）。该脚本已体现若干关键约束：尽量使用标准库（stdlib only）、不在文件中存储明文账号密码、通过入口页发现最新 AJG 年份链接、对网络请求做基本重试与回退。

与此同时，项目未来规划包含“基于 AJG 目录的投稿期刊推荐”能力，并希望封装为可复用的 skill（`ABS-article`）。为降低后续迭代风险，需要用 OpenSpec 将能力边界、输入输出契约、错误/降级行为、目录约定与最小验收标准固定下来，并把实现工作拆成可执行 tasks。

约束与利益相关方：
- 约束：尽量保持脚本可在“无第三方依赖”的环境下运行；默认使用绝对路径；避免在仓库中保存敏感凭据。
- 外部系统不稳定：`charteredabs.org` 可能出现 gated 登录、页面结构变更、验证码/反爬策略，导致抓取失败或行为变化。
- 使用者：项目的唯一长期目标用户为凌贵旺（Guiwang Ling），主要用于学术期刊信息获取与投稿推荐。

## Goals / Non-Goals

**Goals:**
- 用 OpenSpec 将项目拆分为清晰的 capabilities（`ajg-fetch`、`journal-recommendation`、`project-structure-openspec`），并为每个 capability 定义可验证的 spec（输入、输出、字段、退出码、错误提示、兼容性要求）。
- 规范化项目结构与运行方式：明确脚本入口、数据目录、产出文件命名、元数据/日志记录方式，使功能可复用、可迁移、可回归验证。
- 为未来 skill 化（尤其 `ABS-article`）提前固定接口契约，减少“对话式需求”直接侵入实现代码导致的漂移。
- 允许必要的 **BREAKING** 调整，但要求在 specs 中明确，并在任务中提供迁移/兼容策略。

**Non-Goals:**
- 本阶段不追求“全自动、零失败”的网站抓取（外部反爬/验证码不可控）；目标是明确失败模式与降级行为，并保证可诊断。
- 不在 design 阶段实现完整推荐算法细节（模型/评分权重/外部数据库接入等）；这些属于 specs 明确后再在 tasks/实现阶段迭代。
- 不引入重型架构（如数据库服务、Web 后端）作为前置条件；默认保持脚本化/文件落地的轻量方式，除非后续需求明确。

## Decisions

1) **以 capabilities/spec 为中心组织，而不是以脚本文件为中心**
- 决策：把用户可感知的能力拆成 3 个 capabilities，并在 `openspec/specs/<capability>/spec.md` 中定义契约。
- 理由：脚本实现会变，但能力契约应稳定；同时为未来新增实现（例如换抓取方式、增加缓存/镜像源）保留空间。
- 备选方案：仅在 README/注释里描述用法。缺点是不可验证、难以追踪变更，不利于后续 skill 化与多人协作（即便当前主要单人）。

2) **保持 `ajg_fetch.py` 的“stdlib only”约束，并把它写进 specs**
- 决策：继续以标准库为默认实现约束，避免 requests/playwright 等第三方依赖成为运行门槛。
- 理由：降低环境配置成本；对学术用户更友好；并与现有实现保持一致。
- 备选方案：引入第三方库提高健壮性（例如应对 JS 渲染/验证码）。缺点是依赖管理复杂，且不一定真正解决反爬问题；如确需引入，应在 design/specs 中作为显式决策记录，并提供可选路径。

3) **把 I/O 契约和失败模式作为“第一类规格”**
- 决策：在 specs 中明确：
  - 输入：环境变量（如 `AJG_EMAIL`/`AJG_PASSWORD`）、CLI 参数（如 `--outdir`）、默认值、必填校验。
  - 输出：固定文件集（`ajg_<year>_journals_raw.jsonl`、`ajg_<year>_meta.json`、`ajg_<year>_journals_core_custom.csv`）、字段定义与最小字段集合、编码与分隔符。
  - 失败：无权限/被 gated/网络失败/结构变动等场景的错误信息与退出码。
- 理由：这是后续推荐能力的上游依赖；没有稳定 I/O，推荐逻辑无法稳定、也无法测试。
- 备选方案：只保证“能跑出结果”。缺点是长期不可维护、难以对外解释与复现。

4) **以文件落地作为数据层，并提供最小校验**
- 决策：继续使用 `data/` 下的文件作为数据层，不引入数据库；同时在 tasks 中加入最小校验（例如：输出文件存在；CSV 头包含关键列；meta.json 含抓取时间、年份等）。
- 理由：轻量、可审计、易备份；适合当前规模。
- 备选方案：引入 SQLite/Parquet 等。优点是查询更强；缺点是复杂度增加，且不一定必要。

5) **将“期刊推荐”定义为独立 capability，先定接口再定实现**
- 决策：在 `journal-recommendation` 的 spec 中先定义输入（论文信息字段/可选项）、输出（推荐列表结构、解释字段、筛选条件与排序维度）、与对 AJG 数据文件的依赖约束；实现可先从规则/启发式起步。
- 理由：推荐问题天然会迭代；先把接口稳定下来，便于将来替换算法（规则→embedding→LLM 辅助等）。
- 备选方案：直接做一个“对话式 prompt 推荐”。缺点是难以保证一致性与可复现性，且难以形成可测试的 skill。

## Risks / Trade-offs

- [外部站点 gated/验证码/结构变更导致抓取失败] → 在 specs 中明确失败模式与退出码；在 meta.json 记录诊断信息；必要时提供“提示用户手动更新入口链接/年份”的降级路径。
- [stdlib only 导致对复杂网页/JS 渲染支持有限] → 将“引入第三方抓取方案”作为未来可选决策点，不在本轮强制；先确保可诊断与可维护。
- [BREAKING 变更影响既有数据文件/下游流程] → 在 specs 中标注版本与迁移说明；在 tasks 中包含兼容层或迁移脚本（如需要）。
- [推荐能力需求不稳定、范围膨胀] → 在 specs 中限定 v1 范围（输入字段与输出结构）；把更高级的功能列为 Non-Goals 或后续迭代。

